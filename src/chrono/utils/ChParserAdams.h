// =============================================================================
// PROJECT CHRONO - http://projectchrono.org
//
// Copyright (c) 2014 projectchrono.org
// All rights reserved.
//
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file at the top level of the distribution and at
// http://projectchrono.org/license-chrono.txt.
//
// =============================================================================
// Authors: Conlain Kelly
// =============================================================================
//
// Parser utility class for ADMAS .adm input files.
//
// =============================================================================

#ifndef CH_PARSER_ADAMS_H
#define CH_PARSER_ADAMS_H

#include <functional>
#include <map>
#include <sstream>

#include "chrono/core/ChApiCE.h"
#include "chrono/physics/ChBodyAuxRef.h"
#include "chrono/physics/ChSystem.h"

enum TokenType {
    MARKER,
    LABEL,
    VALUE,
    COMMA,
    GRAPHICS,
    PAREN_O,
    PAREN_C,
    NEWLINE,
    EQUALS,
    COMMENT,
    NEGATE,
    ADAMS,
    UNITS,
    PART,
    JOINT,
    REQUEST,
    COLON,
    BACKSLASH,
    ACCGRAV,
    OUTPUT,
    END,
    DELIMITER  // used for primary tokens -- things that are directly represented in Chrono
};

namespace chrono {

namespace utils {

/// @addtogroup chrono_utils
/// @{

/// ADAMS input file parser
class ChApi ChParserAdams {
  public:
    enum VisType { PRIMITIVES, MESH, NONE };

    ChParserAdams() : m_visType(VisType::NONE), m_verbose(false) {}
    ~ChParserAdams() {}

    /// Set body visualization type (default: NONE).
    void SetVisualizationType(VisType val) { m_visType = val; }

    /// Enable/disable verbose parsing output (default: false).
    void SetVerbose(bool val) { m_verbose = val; }

    /// Parse the specified Adams input file and create the model in the given system.
    void Parse(ChSystem& sys,               ///< [in] containing Chrono system
               const std::string& filename  ///< [in] Adams input file name
    );

    /// Parse the specified Adams input file and create the model in a new system.
    /// Note that the created system is not deleted in the parser's destructor;
    /// rather, ownership is transferred to the caller.
    ChSystem* Parse(const std::string& filename,  ///< [in] Adams input file name
                    ChMaterialSurface::ContactMethod contact_method = ChMaterialSurface::NSC  ///< [in] contact method
    );

    /// Get the list of bodies in the model.
    const std::vector<std::shared_ptr<ChBodyAuxRef>>& GetBodyList() const { return m_bodyList; }

    /// Get the list of joints in the model.
    const std::vector<std::shared_ptr<ChLink>>& GetJointList() const { return m_jointList; }

    // Generated by the FLEX stuff, this is an external function that tokenizes things
    int yylex();
    // Holds a list of tokens created by yylex()
    // This should be public so flex can get to it maybe?
    std::vector<std::pair<int, std::string>> m_tokens;

  private:
    // Get an STL vector from a string, used to make the xml parsing cleaner
    void tokenize(const std::string& filename);

    template <typename T>
    static inline std::vector<T> strToSTLVector(const char* string) {
        std::istringstream buf(string);
        std::istream_iterator<T> beg(buf), end;
        return std::vector<T>(beg, end);
    }

    // Maps child fields of a body node to functions that handle said fields
    std::map<std::string, std::function<void(std::istringstream, std::shared_ptr<ChBodyAuxRef>)>> function_table;

    // Maps child fields of a body node to functions that handle said fields

    bool m_verbose;     ///< verbose output
    VisType m_visType;  ///< Body visualization type
    bool m_collide;     ///< Do bodies have collision shapes?
    int m_family_1;     ///< First collision family
    int m_family_2;     ///< Second collision family

    float m_friction;       ///< contact coefficient of friction
    float m_restitution;    ///< contact coefficient of restitution
    float m_young_modulus;  ///< contact material Young modulus
    float m_poisson_ratio;  ///< contact material Poisson ratio
    float m_kn;             ///< normal contact stiffness
    float m_gn;             ///< normal contact damping
    float m_kt;             ///< tangential contact stiffness
    float m_gt;             ///< tangential contact damping

    std::vector<std::shared_ptr<ChBodyAuxRef>> m_bodyList;  ///< List of bodies in model
    std::vector<std::shared_ptr<ChLink>> m_jointList;       ///< List of joints in model
};

// Capture it for our use
#define YY_DECL int chrono::utils::ChParserAdams::yylex()

/// @} chrono_utils

}  // end namespace utils
}  // end namespace chrono

#endif
